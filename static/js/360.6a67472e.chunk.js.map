{"version":3,"file":"static/js/360.6a67472e.chunk.js","mappings":"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","sources":["../node_modules/@rc-component/mutate-observer/es/wrapper.js","../node_modules/@rc-component/mutate-observer/es/useMutateObserver.js","../node_modules/@rc-component/mutate-observer/es/MutateObserver.js","../node_modules/antd/es/watermark/useClips.js","../node_modules/antd/es/watermark/utils.js","../node_modules/antd/es/watermark/useWatermark.js","../node_modules/antd/es/watermark/index.js","../node_modules/antd/es/watermark/useRafDebounce.js","pages/Home.jsx","../node_modules/antd/es/watermark/context.js"],"sourcesContent":["import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"@babel/runtime/helpers/esm/createSuper\";\nimport React from 'react';\nvar DomWrapper = /*#__PURE__*/function (_React$Component) {\n  _inherits(DomWrapper, _React$Component);\n  var _super = _createSuper(DomWrapper);\n  function DomWrapper() {\n    _classCallCheck(this, DomWrapper);\n    return _super.apply(this, arguments);\n  }\n  _createClass(DomWrapper, [{\n    key: \"render\",\n    value: function render() {\n      return this.props.children;\n    }\n  }]);\n  return DomWrapper;\n}(React.Component);\nexport default DomWrapper;","import canUseDom from \"rc-util/es/Dom/canUseDom\";\nimport * as React from 'react';\nvar defaultOptions = {\n  subtree: true,\n  childList: true,\n  attributeFilter: ['style', 'class']\n};\nexport default function useMutateObserver(nodeOrList, callback) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultOptions;\n  React.useEffect(function () {\n    if (!canUseDom() || !nodeOrList) {\n      return;\n    }\n    var instance;\n    var nodeList = Array.isArray(nodeOrList) ? nodeOrList : [nodeOrList];\n    if ('MutationObserver' in window) {\n      instance = new MutationObserver(callback);\n      nodeList.forEach(function (element) {\n        instance.observe(element, options);\n      });\n    }\n    return function () {\n      var _instance, _instance2;\n      (_instance = instance) === null || _instance === void 0 ? void 0 : _instance.takeRecords();\n      (_instance2 = instance) === null || _instance2 === void 0 ? void 0 : _instance2.disconnect();\n    };\n  }, [options, nodeOrList]);\n}","import _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport React from 'react';\nimport useLayoutEffect from \"rc-util/es/hooks/useLayoutEffect\";\nimport { supportRef, useComposeRef } from \"rc-util/es/ref\";\nimport findDOMNode from \"rc-util/es/Dom/findDOMNode\";\nimport useEvent from \"rc-util/es/hooks/useEvent\";\nimport DomWrapper from \"./wrapper\";\nimport useMutateObserver from \"./useMutateObserver\";\nvar MutateObserver = function MutateObserver(props) {\n  var children = props.children,\n    options = props.options,\n    _props$onMutate = props.onMutate,\n    onMutate = _props$onMutate === void 0 ? function () {} : _props$onMutate;\n  var callback = useEvent(onMutate);\n  var wrapperRef = React.useRef(null);\n  var elementRef = React.useRef(null);\n  var canRef = /*#__PURE__*/React.isValidElement(children) && supportRef(children);\n  var mergedRef = useComposeRef(elementRef, canRef ? children.ref : null);\n  var _React$useState = React.useState(null),\n    _React$useState2 = _slicedToArray(_React$useState, 2),\n    target = _React$useState2[0],\n    setTarget = _React$useState2[1];\n  useMutateObserver(target, callback, options);\n\n  // =========================== Effect ===========================\n  // Bind target\n  useLayoutEffect(function () {\n    setTarget(findDOMNode(elementRef.current) || findDOMNode(wrapperRef.current));\n  });\n\n  // =========================== Render ===========================\n  if (!children) {\n    if (process.env.NODE_ENV !== 'production') {\n      console.error('MutationObserver need children props');\n    }\n    return null;\n  }\n  return /*#__PURE__*/React.createElement(DomWrapper, {\n    ref: wrapperRef\n  }, canRef ? /*#__PURE__*/React.cloneElement(children, {\n    ref: mergedRef\n  }) : children);\n};\nexport default MutateObserver;","export const FontGap = 3;\nfunction prepareCanvas(width, height) {\n  let ratio = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  const canvas = document.createElement('canvas');\n  const ctx = canvas.getContext('2d');\n  const realWidth = width * ratio;\n  const realHeight = height * ratio;\n  canvas.setAttribute('width', `${realWidth}px`);\n  canvas.setAttribute('height', `${realHeight}px`);\n  ctx.save();\n  return [ctx, canvas, realWidth, realHeight];\n}\n/**\n * Get the clips of text content.\n * This is a lazy hook function since SSR no need this\n */\nexport default function useClips() {\n  // Get single clips\n  function getClips(content, rotate, ratio, width, height, font, gapX, gapY) {\n    // ================= Text / Image =================\n    const [ctx, canvas, contentWidth, contentHeight] = prepareCanvas(width, height, ratio);\n    if (content instanceof HTMLImageElement) {\n      // Image\n      ctx.drawImage(content, 0, 0, contentWidth, contentHeight);\n    } else {\n      // Text\n      const {\n        color,\n        fontSize,\n        fontStyle,\n        fontWeight,\n        fontFamily,\n        textAlign\n      } = font;\n      const mergedFontSize = Number(fontSize) * ratio;\n      ctx.font = `${fontStyle} normal ${fontWeight} ${mergedFontSize}px/${height}px ${fontFamily}`;\n      ctx.fillStyle = color;\n      ctx.textAlign = textAlign;\n      ctx.textBaseline = 'top';\n      const contents = Array.isArray(content) ? content : [content];\n      contents === null || contents === void 0 ? void 0 : contents.forEach((item, index) => {\n        ctx.fillText(item !== null && item !== void 0 ? item : '', contentWidth / 2, index * (mergedFontSize + FontGap * ratio));\n      });\n    }\n    // ==================== Rotate ====================\n    const angle = Math.PI / 180 * Number(rotate);\n    const maxSize = Math.max(width, height);\n    const [rCtx, rCanvas, realMaxSize] = prepareCanvas(maxSize, maxSize, ratio);\n    // Copy from `ctx` and rotate\n    rCtx.translate(realMaxSize / 2, realMaxSize / 2);\n    rCtx.rotate(angle);\n    if (contentWidth > 0 && contentHeight > 0) {\n      rCtx.drawImage(canvas, -contentWidth / 2, -contentHeight / 2);\n    }\n    // Get boundary of rotated text\n    function getRotatePos(x, y) {\n      const targetX = x * Math.cos(angle) - y * Math.sin(angle);\n      const targetY = x * Math.sin(angle) + y * Math.cos(angle);\n      return [targetX, targetY];\n    }\n    let left = 0;\n    let right = 0;\n    let top = 0;\n    let bottom = 0;\n    const halfWidth = contentWidth / 2;\n    const halfHeight = contentHeight / 2;\n    const points = [[0 - halfWidth, 0 - halfHeight], [0 + halfWidth, 0 - halfHeight], [0 + halfWidth, 0 + halfHeight], [0 - halfWidth, 0 + halfHeight]];\n    points.forEach(_ref => {\n      let [x, y] = _ref;\n      const [targetX, targetY] = getRotatePos(x, y);\n      left = Math.min(left, targetX);\n      right = Math.max(right, targetX);\n      top = Math.min(top, targetY);\n      bottom = Math.max(bottom, targetY);\n    });\n    const cutLeft = left + realMaxSize / 2;\n    const cutTop = top + realMaxSize / 2;\n    const cutWidth = right - left;\n    const cutHeight = bottom - top;\n    // ================ Fill Alternate ================\n    const realGapX = gapX * ratio;\n    const realGapY = gapY * ratio;\n    const filledWidth = (cutWidth + realGapX) * 2;\n    const filledHeight = cutHeight + realGapY;\n    const [fCtx, fCanvas] = prepareCanvas(filledWidth, filledHeight);\n    function drawImg() {\n      let targetX = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      let targetY = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      fCtx.drawImage(rCanvas, cutLeft, cutTop, cutWidth, cutHeight, targetX, targetY, cutWidth, cutHeight);\n    }\n    drawImg();\n    drawImg(cutWidth + realGapX, -cutHeight / 2 - realGapY / 2);\n    drawImg(cutWidth + realGapX, +cutHeight / 2 + realGapY / 2);\n    return [fCanvas.toDataURL(), filledWidth / ratio, filledHeight / ratio];\n  }\n  return getClips;\n}","/** converting camel-cased strings to be lowercase and link it with Separato */\nexport function toLowercaseSeparator(key) {\n  return key.replace(/([A-Z])/g, '-$1').toLowerCase();\n}\nexport function getStyleStr(style) {\n  return Object.keys(style).map(key => `${toLowercaseSeparator(key)}: ${style[key]};`).join(' ');\n}\n/** Returns the ratio of the device's physical pixel resolution to the css pixel resolution */\nexport function getPixelRatio() {\n  return window.devicePixelRatio || 1;\n}\n/** Whether to re-render the watermark */\nexport const reRendering = (mutation, isWatermarkEle) => {\n  let flag = false;\n  // Whether to delete the watermark node\n  if (mutation.removedNodes.length) {\n    flag = Array.from(mutation.removedNodes).some(node => isWatermarkEle(node));\n  }\n  // Whether the watermark dom property value has been modified\n  if (mutation.type === 'attributes' && isWatermarkEle(mutation.target)) {\n    flag = true;\n  }\n  return flag;\n};","import * as React from 'react';\nimport { getStyleStr } from './utils';\n/**\n * Base size of the canvas, 1 for parallel layout and 2 for alternate layout\n * Only alternate layout is currently supported\n */\nexport const BaseSize = 2;\nexport const FontGap = 3;\n// Prevent external hidden elements from adding accent styles\nconst emphasizedStyle = {\n  visibility: 'visible !important'\n};\nexport default function useWatermark(markStyle) {\n  const [watermarkMap] = React.useState(() => new Map());\n  const appendWatermark = (base64Url, markWidth, container) => {\n    if (container) {\n      if (!watermarkMap.get(container)) {\n        const newWatermarkEle = document.createElement('div');\n        watermarkMap.set(container, newWatermarkEle);\n      }\n      const watermarkEle = watermarkMap.get(container);\n      watermarkEle.setAttribute('style', getStyleStr(Object.assign(Object.assign(Object.assign({}, markStyle), {\n        backgroundImage: `url('${base64Url}')`,\n        backgroundSize: `${Math.floor(markWidth)}px`\n      }), emphasizedStyle)));\n      // Prevents using the browser `Hide Element` to hide watermarks\n      watermarkEle.removeAttribute('class');\n      container.append(watermarkEle);\n    }\n  };\n  const removeWatermark = container => {\n    const watermarkEle = watermarkMap.get(container);\n    if (watermarkEle && container) {\n      container.removeChild(watermarkEle);\n    }\n    watermarkMap.delete(container);\n  };\n  const isWatermarkEle = ele => Array.from(watermarkMap.values()).includes(ele);\n  return [appendWatermark, removeWatermark, isWatermarkEle];\n}","\"use client\";\n\nimport _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\nimport React, { useEffect } from 'react';\nimport { useMutateObserver } from '@rc-component/mutate-observer';\nimport classNames from 'classnames';\nimport { useToken } from '../theme/internal';\nimport WatermarkContext from './context';\nimport useClips, { FontGap } from './useClips';\nimport useRafDebounce from './useRafDebounce';\nimport useWatermark from './useWatermark';\nimport { getPixelRatio, reRendering } from './utils';\n/**\n * Only return `next` when size changed.\n * This is only used for elements compare, not a shallow equal!\n */\nfunction getSizeDiff(prev, next) {\n  return prev.size === next.size ? prev : next;\n}\nconst DEFAULT_GAP_X = 100;\nconst DEFAULT_GAP_Y = 100;\nconst Watermark = props => {\n  var _a, _b;\n  const {\n    /**\n     * The antd content layer zIndex is basically below 10\n     * https://github.com/ant-design/ant-design/blob/6192403b2ce517c017f9e58a32d58774921c10cd/components/style/themes/default.less#L335\n     */\n    zIndex = 9,\n    rotate = -22,\n    width,\n    height,\n    image,\n    content,\n    font = {},\n    style,\n    className,\n    rootClassName,\n    gap = [DEFAULT_GAP_X, DEFAULT_GAP_Y],\n    offset,\n    children,\n    inherit = true\n  } = props;\n  const [, token] = useToken();\n  const {\n    color = token.colorFill,\n    fontSize = token.fontSizeLG,\n    fontWeight = 'normal',\n    fontStyle = 'normal',\n    fontFamily = 'sans-serif',\n    textAlign = 'center'\n  } = font;\n  const [gapX = DEFAULT_GAP_X, gapY = DEFAULT_GAP_Y] = gap;\n  const gapXCenter = gapX / 2;\n  const gapYCenter = gapY / 2;\n  const offsetLeft = (_a = offset === null || offset === void 0 ? void 0 : offset[0]) !== null && _a !== void 0 ? _a : gapXCenter;\n  const offsetTop = (_b = offset === null || offset === void 0 ? void 0 : offset[1]) !== null && _b !== void 0 ? _b : gapYCenter;\n  const markStyle = React.useMemo(() => {\n    const mergedStyle = {\n      zIndex,\n      position: 'absolute',\n      left: 0,\n      top: 0,\n      width: '100%',\n      height: '100%',\n      pointerEvents: 'none',\n      backgroundRepeat: 'repeat'\n    };\n    /** Calculate the style of the offset */\n    let positionLeft = offsetLeft - gapXCenter;\n    let positionTop = offsetTop - gapYCenter;\n    if (positionLeft > 0) {\n      mergedStyle.left = `${positionLeft}px`;\n      mergedStyle.width = `calc(100% - ${positionLeft}px)`;\n      positionLeft = 0;\n    }\n    if (positionTop > 0) {\n      mergedStyle.top = `${positionTop}px`;\n      mergedStyle.height = `calc(100% - ${positionTop}px)`;\n      positionTop = 0;\n    }\n    mergedStyle.backgroundPosition = `${positionLeft}px ${positionTop}px`;\n    return mergedStyle;\n  }, [zIndex, offsetLeft, gapXCenter, offsetTop, gapYCenter]);\n  const [container, setContainer] = React.useState();\n  // Used for nest case like Modal, Drawer\n  const [subElements, setSubElements] = React.useState(new Set());\n  // Nest elements should also support watermark\n  const targetElements = React.useMemo(() => {\n    const list = container ? [container] : [];\n    return [].concat(list, _toConsumableArray(Array.from(subElements)));\n  }, [container, subElements]);\n  // ============================ Content =============================\n  /**\n   * Get the width and height of the watermark. The default values are as follows\n   * Image: [120, 64]; Content: It's calculated by content;\n   */\n  const getMarkSize = ctx => {\n    let defaultWidth = 120;\n    let defaultHeight = 64;\n    if (!image && ctx.measureText) {\n      ctx.font = `${Number(fontSize)}px ${fontFamily}`;\n      const contents = Array.isArray(content) ? content : [content];\n      const sizes = contents.map(item => {\n        const metrics = ctx.measureText(item);\n        return [metrics.width, metrics.fontBoundingBoxAscent + metrics.fontBoundingBoxDescent];\n      });\n      defaultWidth = Math.ceil(Math.max.apply(Math, _toConsumableArray(sizes.map(size => size[0]))));\n      defaultHeight = Math.ceil(Math.max.apply(Math, _toConsumableArray(sizes.map(size => size[1])))) * contents.length + (contents.length - 1) * FontGap;\n    }\n    return [width !== null && width !== void 0 ? width : defaultWidth, height !== null && height !== void 0 ? height : defaultHeight];\n  };\n  const getClips = useClips();\n  const [watermarkInfo, setWatermarkInfo] = React.useState(null);\n  // Generate new Watermark content\n  const renderWatermark = () => {\n    const canvas = document.createElement('canvas');\n    const ctx = canvas.getContext('2d');\n    if (ctx) {\n      const ratio = getPixelRatio();\n      const [markWidth, markHeight] = getMarkSize(ctx);\n      const drawCanvas = drawContent => {\n        const [nextClips, clipWidth] = getClips(drawContent || '', rotate, ratio, markWidth, markHeight, {\n          color,\n          fontSize,\n          fontStyle,\n          fontWeight,\n          fontFamily,\n          textAlign\n        }, gapX, gapY);\n        setWatermarkInfo([nextClips, clipWidth]);\n      };\n      if (image) {\n        const img = new Image();\n        img.onload = () => {\n          drawCanvas(img);\n        };\n        img.onerror = () => {\n          drawCanvas(content);\n        };\n        img.crossOrigin = 'anonymous';\n        img.referrerPolicy = 'no-referrer';\n        img.src = image;\n      } else {\n        drawCanvas(content);\n      }\n    }\n  };\n  const syncWatermark = useRafDebounce(renderWatermark);\n  // ============================= Effect =============================\n  // Append watermark to the container\n  const [appendWatermark, removeWatermark, isWatermarkEle] = useWatermark(markStyle);\n  useEffect(() => {\n    if (watermarkInfo) {\n      targetElements.forEach(holder => {\n        appendWatermark(watermarkInfo[0], watermarkInfo[1], holder);\n      });\n    }\n  }, [watermarkInfo, targetElements]);\n  // ============================ Observe =============================\n  const onMutate = mutations => {\n    mutations.forEach(mutation => {\n      if (reRendering(mutation, isWatermarkEle)) {\n        syncWatermark();\n      }\n    });\n  };\n  useMutateObserver(targetElements, onMutate);\n  useEffect(syncWatermark, [rotate, zIndex, width, height, image, content, color, fontSize, fontWeight, fontStyle, fontFamily, textAlign, gapX, gapY, offsetLeft, offsetTop]);\n  // ============================ Context =============================\n  const watermarkContext = React.useMemo(() => ({\n    add: ele => {\n      setSubElements(prev => {\n        const clone = new Set(prev);\n        clone.add(ele);\n        return getSizeDiff(prev, clone);\n      });\n    },\n    remove: ele => {\n      removeWatermark(ele);\n      setSubElements(prev => {\n        const clone = new Set(prev);\n        clone.delete(ele);\n        return getSizeDiff(prev, clone);\n      });\n    }\n  }), []);\n  // ============================= Render =============================\n  const childNode = inherit ? ( /*#__PURE__*/React.createElement(WatermarkContext.Provider, {\n    value: watermarkContext\n  }, children)) : children;\n  return /*#__PURE__*/React.createElement(\"div\", {\n    ref: setContainer,\n    className: classNames(className, rootClassName),\n    style: Object.assign({\n      position: 'relative'\n    }, style)\n  }, childNode);\n};\nif (process.env.NODE_ENV !== 'production') {\n  Watermark.displayName = 'Watermark';\n}\nexport default Watermark;","import React from 'react';\nimport raf from \"rc-util/es/raf\";\nimport { useEvent } from 'rc-util';\n/**\n * Callback will only execute last one for each raf\n */\nexport default function useRafDebounce(callback) {\n  const executeRef = React.useRef(false);\n  const rafRef = React.useRef();\n  const wrapperCallback = useEvent(callback);\n  return () => {\n    if (executeRef.current) {\n      return;\n    }\n    executeRef.current = true;\n    wrapperCallback();\n    rafRef.current = raf(() => {\n      executeRef.current = false;\n    });\n  };\n}","import { Watermark } from 'antd';\n\nconst styles = {\n  container: {\n    minHeight: 'calc(50vh - 50px)',\n    minWidth: 'calc(50vw - 50px)',\n    display: 'flex',\n    alignItems: 'center',\n    justifyContent: 'center',\n    flexDirection: 'column',\n  },\n  title: {\n    fontWeight: 700,\n    fontSize: 30,\n    textAlign: 'center',\n  },\n};\n\nconst Home = () => (\n  <Watermark gap={[50, 50]}>\n    <div style={styles.container}>\n      <h1 style={styles.title}>Home page of the Phonebook</h1>\n    </div>\n  </Watermark>\n);\n\nexport default Home;","import { useEvent } from 'rc-util';\nimport * as React from 'react';\nfunction voidFunc() {}\nconst WatermarkContext = /*#__PURE__*/React.createContext({\n  add: voidFunc,\n  remove: voidFunc\n});\nexport function usePanelRef(panelSelector) {\n  const watermark = React.useContext(WatermarkContext);\n  const panelEleRef = React.useRef();\n  const panelRef = useEvent(ele => {\n    if (ele) {\n      const innerContentEle = panelSelector ? ele.querySelector(panelSelector) : ele;\n      watermark.add(innerContentEle);\n      panelEleRef.current = innerContentEle;\n    } else {\n      watermark.remove(panelEleRef.current);\n    }\n  });\n  return panelRef;\n}\nexport default WatermarkContext;"],"names":["React","defaultOptions","subtree","childList","attributeFilter","prepareCanvas","width","height","ratio","arguments","length","undefined","canvas","document","createElement","ctx","getContext","realWidth","realHeight","setAttribute","concat","save","useClips","content","rotate","font","gapX","gapY","_prepareCanvas","_prepareCanvas2","_slicedToArray","contentWidth","contentHeight","HTMLImageElement","drawImage","color","fontSize","fontStyle","fontWeight","fontFamily","textAlign","mergedFontSize","Number","fillStyle","textBaseline","contents","Array","isArray","forEach","item","index","fillText","angle","Math","PI","maxSize","max","_prepareCanvas3","_prepareCanvas4","rCtx","rCanvas","realMaxSize","translate","left","right","top","bottom","halfWidth","halfHeight","_ref","_ref2","_getRotatePos","x","y","cos","sin","getRotatePos","_getRotatePos2","targetX","targetY","min","cutLeft","cutTop","cutWidth","cutHeight","realGapX","realGapY","filledWidth","filledHeight","_prepareCanvas5","_prepareCanvas6","fCtx","fCanvas","drawImg","toDataURL","emphasizedStyle","visibility","useWatermark","markStyle","_React$useState","Map","watermarkMap","base64Url","markWidth","container","get","newWatermarkEle","set","watermarkEle","style","Object","assign","backgroundImage","backgroundSize","floor","keys","map","key","replace","toLowerCase","toLowercaseSeparator","join","removeAttribute","append","removeChild","delete","ele","from","values","includes","getSizeDiff","prev","next","size","props","_a","_b","_props$zIndex","zIndex","_props$rotate","image","_props$font","className","rootClassName","_props$gap","gap","offset","children","_props$inherit","inherit","_useToken","useToken","token","_font$color","colorFill","_font$fontSize","fontSizeLG","_font$fontWeight","_font$fontStyle","_font$fontFamily","_font$textAlign","_gap","_gap$","_gap$2","gapXCenter","gapYCenter","offsetLeft","offsetTop","mergedStyle","position","pointerEvents","backgroundRepeat","positionLeft","positionTop","backgroundPosition","_React$useState2","setContainer","_React$useState3","Set","_React$useState4","subElements","setSubElements","targetElements","_toConsumableArray","getClips","_React$useState5","_React$useState6","watermarkInfo","setWatermarkInfo","syncWatermark","callback","executeRef","rafRef","wrapperCallback","useEvent","current","raf","useRafDebounce","window","devicePixelRatio","_getMarkSize","defaultWidth","defaultHeight","measureText","sizes","metrics","fontBoundingBoxAscent","fontBoundingBoxDescent","ceil","apply","getMarkSize","_getMarkSize2","markHeight","drawCanvas","drawContent","_getClips","_getClips2","nextClips","clipWidth","img","Image","onload","onerror","crossOrigin","referrerPolicy","src","_useWatermark","_useWatermark2","appendWatermark","removeWatermark","isWatermarkEle","useEffect","holder","nodeOrList","options","canUseDom","instance","nodeList","MutationObserver","element","observe","_instance","_instance2","takeRecords","disconnect","useMutateObserver","mutations","mutation","flag","removedNodes","some","node","type","target","reRendering","watermarkContext","add","clone","remove","childNode","WatermarkContext","value","ref","classNames","styles","minHeight","minWidth","display","alignItems","justifyContent","flexDirection","title","_jsx","Watermark","voidFunc","usePanelRef","panelSelector","watermark","panelEleRef","innerContentEle","querySelector"],"sourceRoot":""}